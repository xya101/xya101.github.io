<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Bubble Shooter</h1>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <div id="score">Score: <span id="score-value">0</span></div>
        <div id="instructions">
            <p>Click to shoot bubbles</p>
            <p>Match 3 or more of the same color</p>
        </div>
        <a href="index.html" class="game-button">Back to Home</a>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-value');

        const BUBBLE_RADIUS = 20;
        const COLORS = ['red', 'blue', 'green', 'yellow', 'purple'];
        const ROWS = 8;
        const COLS = 10;

        let bubbles = [];
        let shooter = { x: canvas.width / 2, y: canvas.height - BUBBLE_RADIUS };
        let currentBubble = null;
        let score = 0;

        function initGame() {
            bubbles = [];
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < COLS; j++) {
                    if (Math.random() < 0.7) { // 70% chance to spawn a bubble
                        bubbles.push({
                            x: j * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + (i % 2 ? BUBBLE_RADIUS : 0),
                            y: i * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS,
                            color: COLORS[Math.floor(Math.random() * COLORS.length)]
                        });
                    }
                }
            }
            createNewBubble();
        }

        function createNewBubble() {
            currentBubble = {
                x: shooter.x,
                y: shooter.y,
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                dx: 0,
                dy: 0
            };
        }

        function drawBubble(bubble) {
            ctx.beginPath();
            ctx.arc(bubble.x, bubble.y, BUBBLE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = bubble.color;
            ctx.fill();
            ctx.closePath();
        }

        function drawShooter() {
            ctx.beginPath();
            ctx.moveTo(shooter.x, shooter.y);
            ctx.lineTo(shooter.x - 10, shooter.y + 20);
            ctx.lineTo(shooter.x + 10, shooter.y + 20);
            ctx.fillStyle = 'gray';
            ctx.fill();
            ctx.closePath();
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            bubbles.forEach(drawBubble);
            drawShooter();

            if (currentBubble) {
                currentBubble.x += currentBubble.dx;
                currentBubble.y += currentBubble.dy;
                drawBubble(currentBubble);

                if (currentBubble.y <= BUBBLE_RADIUS || checkCollision()) {
                    snapToGrid();
                    checkMatches();
                    createNewBubble();
                }
            }

            scoreDisplay.textContent = score;
            requestAnimationFrame(update);
        }

        function checkCollision() {
            return bubbles.some(bubble => 
                Math.hypot(bubble.x - currentBubble.x, bubble.y - currentBubble.y) < BUBBLE_RADIUS * 2
            );
        }

        function snapToGrid() {
            let row = Math.round((currentBubble.y - BUBBLE_RADIUS) / (BUBBLE_RADIUS * 2));
            let col = Math.round((currentBubble.x - BUBBLE_RADIUS - (row % 2 ? BUBBLE_RADIUS : 0)) / (BUBBLE_RADIUS * 2));
            currentBubble.x = col * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + (row % 2 ? BUBBLE_RADIUS : 0);
            currentBubble.y = row * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS;
            bubbles.push(currentBubble);
        }

        function checkMatches() {
            let matches = findMatches(currentBubble);
            if (matches.length >= 3) {
                matches.forEach(bubble => {
                    let index = bubbles.indexOf(bubble);
                    if (index > -1) bubbles.splice(index, 1);
                });
                score += matches.length * 10;
            }
        }

        function findMatches(bubble, matches = [], visited = new Set()) {
            if (visited.has(bubble)) return matches;
            visited.add(bubble);
            matches.push(bubble);

            bubbles.forEach(otherBubble => {
                if (otherBubble.color === bubble.color &&
                    Math.hypot(otherBubble.x - bubble.x, otherBubble.y - bubble.y) < BUBBLE_RADIUS * 2.1) {
                    findMatches(otherBubble, matches, visited);
                }
            });

            return matches;
        }

        canvas.addEventListener('click', (e) => {
            if (currentBubble) {
                let rect = canvas.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;
                let angle = Math.atan2(y - shooter.y, x - shooter.x);
                currentBubble.dx = Math.cos(angle) * 5;
                currentBubble.dy = Math.sin(angle) * 5;
            }
        });

        initGame();
        update();
    </script>
</body>
</html>